# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, test
# This file is distributed under the same license as the qubes-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: qubes-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-15 21:10+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../developer/services/qrexec.md:17
#: 7e52e067f54e456bbdbd4577e0d2001c
msgid "(*This page is about qrexec v3. For qrexec v2, see [here](/doc/qrexec2/).*)"
msgstr ""

#: ../developer/services/qrexec.md:19
#: e1bed79172164929aa002f3954bc7a85
msgid "The **qrexec framework** is used by core Qubes components to implement communication between domains. Qubes domains are strictly isolated by design. However, the OS needs a mechanism to allow the administrative domain (dom0) to force command execution in another domain (VM). For instance, when a user selects an application from the KDE menu, it should start in the selected VM. Also, it is often useful to be able to pass stdin/stdout/stderr from an application running in a VM to dom0 (and the other way around). (For example, so that a VM can notify dom0 that there are updates available for it). By default, Qubes allows VMs initiate such communications in specific circumstances. The qrexec framework generalizes this process by providing a remote procedure call (RPC) protocol for the Qubes architecture. It allows users and developers to use and design secure inter-VM tools."
msgstr ""

#: ../developer/services/qrexec.md:29
#: 84372878e8ff4d54abaf8ff8cf115fca
msgid "Qrexec basics: architecture and examples"
msgstr ""

#: ../developer/services/qrexec.md:31
#: b13b09a766194cbabcef59d1bb2742a3
msgid "Qrexec is built on top of *vchan*, a Xen library providing data links between VMs. During domain startup , a process named `qrexec-daemon` is started in dom0, and a process named `qrexec-agent` is started in the VM. They are connected over a **vchan** channel. `qrexec-daemon` listens for connections from a dom0 utility named `qrexec-client`. Let's say we want to start a process (call it `VMprocess`) in a VM (`someVM`). Typically, the first thing that a `qrexec-client` instance does is to send a request to the `qrexec-daemon`, which in turn relays it to `qrexec-agent` running in `someVM`. `qrexec-daemon` assigns unique vchan connection details and sends them to both `qrexec-client` (in dom0) and `qrexec-agent` (in `someVM`). `qrexec-client` starts a vchan server, which `qrexec-agent` then connects to. Once this channel is established, stdin/stdout/stderr from the VMprocess is passed between `qrexec-agent` and the `qrexec-client` process."
msgstr ""

#: ../developer/services/qrexec.md:41
#: 1fba45abf03448df8ca8fccdb8c18b24
msgid "![qrexec basics diagram](/attachment/doc/qrexec3-basics.png)"
msgstr ""

#: ../developer/services/qrexec.md:41
#: 60173c3a2d8f475f905e70d32d64a12f
msgid "qrexec basics diagram"
msgstr ""

#: ../developer/services/qrexec.md:43
#: b4d003e28b8249458af6874e37ea8f45
msgid "The `qrexec-client` command is used to make connections to VMs from dom0. For example, the following command creates an empty file called `hello-world.txt` in the home folder of `someVM`:"
msgstr ""

#: ../developer/services/qrexec.md:50
#: 5d06bfd2d73d4a9a8714e14f8f10fc1f
msgid "The string before the colon specifies what user to run the command as. The `-e` flag tells `qrexec-client` to exit immediately after sending the execution request and receiving a status code from `qrexec-agent` (whether the process creation succeeded). With this option, no further data is passed between the domains. By contrast, the following command demonstrates an open channel between dom0 and someVM (in this case, a remote shell):"
msgstr ""

#: ../developer/services/qrexec.md:59
#: c860dcad6d934143a4a67e1529f168a2
msgid "The `qvm-run` command is heavily based on `qrexec-client`. It also takes care of additional activities, e.g. starting the domain if it is not up yet and starting the GUI daemon. Thus, it is usually more convenient to use `qvm-run`."
msgstr ""

#: ../developer/services/qrexec.md:63
#: 474dd35f666f40ad8ae4677777838e74
msgid "There can be an almost arbitrary number of `qrexec-client` processes for a given domain. The limiting factor is the number of available vchan channels, which depends on the underlying hypervisor, as well the domain's OS."
msgstr ""

#: ../developer/services/qrexec.md:66
#: a4c2350913aa4b4185d28d5b7d8998b5
msgid "For more details on the qrexec framework and protocol, see \"[Qubes RPC internals](/doc/qrexec-internals).\""
msgstr ""

#: ../developer/services/qrexec.md:68
#: 2eefb2ef29214761a0247b50007f9831
msgid "Qubes RPC services"
msgstr ""

#: ../developer/services/qrexec.md:70
#: de8e9dfed2b044a2b95ad6142e721ff8
msgid "Some common tasks (like copying files between VMs) have an RPC-like structure: a process in one VM (say, the file sender) needs to invoke and send/receive data to some process in other VM (say, the file receiver). The Qubes RPC framework was created to securely facilitate a range of such actions."
msgstr ""

#: ../developer/services/qrexec.md:73
#: 1d26d960f1d945d48099d5c22df78d5e
msgid "Obviously, inter-VM communication must be tightly controlled to prevent one VM from taking control of another, possibly more privileged, VM. Therefore the design decision was made to pass all control communication via dom0, that can enforce proper authorization. Then, it is natural to reuse the already-existing qrexec framework."
msgstr ""

#: ../developer/services/qrexec.md:77
#: 8c472c41a0c24273b7a707d2f5f9ba17
msgid "Also, note that bare qrexec provides `VM <-> dom0` connectivity, but the command execution is always initiated by dom0. There are cases when VM needs to invoke and send data to a command in dom0 (e.g. to pass information on newly installed `.desktop` files). Thus, the framework allows dom0 to be the RPC target as well."
msgstr ""

#: ../developer/services/qrexec.md:81
#: 6d641d8bdc62453ca32748097c2bbd67
msgid "Thanks to the framework, RPC programs are very simple -- both RPC client and server just use their stdin/stdout to pass data. The framework does all the inner work to connect these processes to each other via `qrexec-daemon` and `qrexec-agent`. Additionally, disposable VMs are tightly integrated -- RPC to a DisposableVM is identical to RPC to a normal domain, all one needs is to pass `@dispvm` as the remote domain name."
msgstr ""

#: ../developer/services/qrexec.md:85
#: b62ae2641bc54f6b900e6968984c1a7b
msgid "Qubes RPC administration"
msgstr ""

#: ../developer/services/qrexec.md:87
#: 76f0e3c5361c4fa6b070db3c15cf2e89
msgid "Policy files"
msgstr ""

#: ../developer/services/qrexec.md:89
#: e53a1532c46a40f6b69ddd218f0e109b
msgid "The dom0 directory `/etc/qubes-rpc/policy/` contains a file for each available RPC action that a VM might call. Together the contents of these files make up the RPC access policy database. Policies are defined in lines with the following format:"
msgstr ""

#: ../developer/services/qrexec.md:97
#: 9721faccaab7412c849284dfabaade81
msgid "You can specify srcvm and destvm by name or by one of the reserved keywords such as `@anyvm`, `@dispvm`, or `dom0`. (Of these three, only `@anyvm` keyword makes sense in the srcvm field. Service calls from dom0 are currently always allowed, and `@dispvm` means \"new VM created for this particular request,\" so it is never a source of request.) Other methods using *tags* and *types* are also available (and discussed below)."
msgstr ""

#: ../developer/services/qrexec.md:102
#: 30fed5168af1429fba65eeddbf010d2b
msgid "Whenever a RPC request for an action is received, the domain checks the first matching line of the relevant file in `/etc/qubes-rpc/policy/` to determine access: whether to allow the request, what VM to redirect the execution to, and what user account the program should run under. Note that if the request is redirected (`target=` parameter), policy action remains the same -- even if there is another rule which would otherwise deny such request. If no policy rule is matched, the action is denied. If the policy file does not exist, the user is prompted to create one. If there is still no policy file after prompting, the action is denied."
msgstr ""

#: ../developer/services/qrexec.md:109
#: 4285dd6ec40b4ec5bdc5f7bef002da31
msgid "In the target VM, the file `/etc/qubes-rpc/RPC_ACTION_NAME` must exist, containing the file name of the program that will be invoked, or being that program itself -- in which case it must have executable permission set (`chmod +x`)."
msgstr ""

#: ../developer/services/qrexec.md:111
#: 29dec1afc9114ab4aaac60f711cf1dde
msgid "Making an RPC call"
msgstr ""

#: ../developer/services/qrexec.md:113
#: e35017d5f40547d8b4cda51e104db35c
msgid "From outside of dom0, RPC calls take the following form:"
msgstr ""

#: ../developer/services/qrexec.md:119
#: 7c2b54731b6b40e1be4db4b9cd232760
msgid "For example:"
msgstr ""

#: ../developer/services/qrexec.md:125
#: 574d0c3e6fc3451a95aa2ae9713136ac
msgid "Note that only stdin/stdout is passed between RPC server and client -- notably, no command line arguments are passed. By default, stderr of client and server is logged in the syslog/journald of the VM where the process is running."
msgstr ""

#: ../developer/services/qrexec.md:128
#: 25a2034ce4bf406b8d1a6baa135f8dd8
msgid "It is also possible to call service without specific client program -- in which case server stdin/out will be connected with the terminal:"
msgstr ""

#: ../developer/services/qrexec.md:134
#: 98ec17890fba463c8bf0f8a49fb04321
msgid "Specifying VMs: tags, types, targets, etc."
msgstr ""

#: ../developer/services/qrexec.md:136
#: c2a3bc8e1f8241deb8e23897c09e226b
msgid "There are severals methods for specifying source/target VMs in RPC policies."
msgstr ""

#: ../developer/services/qrexec.md:138
#: 02fb0cf40c2f4e8494f6246fdc4055bc
msgid "`@tag:some-tag` - meaning a VM with tag `some-tag`"
msgstr ""

#: ../developer/services/qrexec.md:139
#: 411d31b4c79f48a1a08d203ec0cb714d
msgid "`@type:type` - meaning a VM of `type` (like `AppVM`, `TemplateVM` etc)"
msgstr ""

#: ../developer/services/qrexec.md:141
#: d006f29202fe4234b204b47b449e08db
msgid "Target VM can be also specified as `@default`, which matches the case when calling VM didn't specified any particular target (either by using `@default` target, or empty target). For DisposableVMs, `@dispvm:DISP_VM` is very similar to `@dispvm` but forces using a particular VM (`DISP_VM`) as a base VM to be started as DisposableVM. For example:"
msgstr ""

#: ../developer/services/qrexec.md:149
#: 8536202b6a6d49b7a62abb86f4a32ae5
msgid "Adding such policy itself will not force usage of this particular `DISP_VM` - it will only allow it when specified by the caller. But `@dispvm:DISP_VM` can also be used as target in request redirection, so _it is possible_ to force particular `DISP_VM` usage, when caller didn't specify it:"
msgstr ""

#: ../developer/services/qrexec.md:156
#: eb8a48b6e48b4bd980b04e33d204ed7f
msgid "Note that without redirection, this rule would allow using default Disposable VM (`default_dispvm` VM property, which itself defaults to global `default_dispvm` property). Also note that the request will be allowed (`allow` action) even if there is no second rule allowing calls to `@dispvm:anon-whonix-dvm`, or even if there is a rule explicitly denying it. This is because the redirection happens _after_ considering the action."
msgstr ""

#: ../developer/services/qrexec.md:160
#: 68f8ec41723a4307ade120a63b12ec48
msgid "The policy confirmation dialog (`ask` action) allows the user to specify target VM. User can choose from VMs that, according to policy, would lead to `ask` or `allow` actions. It is not possible to select VM that policy would deny. By default no VM is selected, even if the caller provided some, but policy can specify default value using `default_target=` parameter. For example:"
msgstr ""

#: ../developer/services/qrexec.md:172
#: fcbb7d3f030a4596b0dcf0e64e96b5d5
msgid "The first rule allow call from `work-mail` to `work-archive`, without any confirmation. The second rule will ask the user about calls from `work-mail` VM to any VM with tag `work`. And the confirmation dialog will have `work-files` VM chosen by default, regardless of the VM specified by the caller (`work-mail` VM). The third rule allow the caller to not specify target VM at all and let the user choose, still - from VMs with tag `work` (and `work-archive`, regardless of tag), and with `work-files` as default."
msgstr ""

#: ../developer/services/qrexec.md:177
#: c582feb355d844f5a76f4871b397b5cb
msgid "RPC services and security"
msgstr ""

#: ../developer/services/qrexec.md:179
#: 51d74e9b3e1444ef83e3f3233fdcf0dd
msgid "Be very careful when coding and adding a new RPC service. Unless the offered functionality equals full control over the target (it is the case with e.g. `qubes.VMShell` action), any vulnerability in an RPC server can be fatal to Qubes security. On the other hand, this mechanism allows to delegate processing of untrusted input to less privileged (or disposable) AppVMs, thus wise usage of it increases security."
msgstr ""

#: ../developer/services/qrexec.md:183
#: 05e272cbca4e40daa481eeed2f9190f8
msgid "For example, this command will run the `firefox` command in a DisposableVM based on `work`:"
msgstr ""

#: ../developer/services/qrexec.md:189
#: 4b2d65fd2ebf46a492e3ea9586db8f9b
msgid "By contrast, consider this command:"
msgstr ""

#: ../developer/services/qrexec.md:195
#: 0540682403f54ff4bc57e81517824ea6
msgid "This will look for a `firefox.desktop` file in a standard location in a DisposableVM based on `work`, then launch the application described by that file. The practical difference is that the bare `qvm-run` command uses the `qubes.VMShell` service, which allows you to run an arbitrary command with arbitrary arguments, essentially providing full control over the target VM. By contrast, the `qubes.StartApp` service allows you to run only applications that are advertised in `/usr/share/applications` (or other standard locations) *without* control over the arguments, so giving a VM access to `qubes.StartApp` is much safer. While there isn't much practical difference between the two commands above when starting an application from dom0 in Qubes 4.0, there is a significant security risk when launching applications from a domU (e.g., from a separate GUI domain). This is why `qubes.StartApp` uses our standard `qrexec` argument grammar to strictly filter the permissible grammar of the `Exec=` lines in `.desktop` files that are passed from untrusted domUs to dom0, thereby protecting dom0 from command injection by maliciously-crafted `.desktop` files."
msgstr ""

#: ../developer/services/qrexec.md:201
#: 4652cd44232c471097fed0eca2adc3fc
msgid "Service policies with arguments"
msgstr ""

#: ../developer/services/qrexec.md:203
#: 6ae5c7a1ebf1419c884b89464f99e175
msgid "Sometimes a service name alone isn't enough to make reasonable qrexec policy. One example of such a situation is [qrexec-based USB passthrough](/doc/how-to-use-usb-devices/). Using just a service name would make it difficult to express the policy \"allow access to devices X and Y, but deny to all others.\" It isn't feasible to create a separate service for every device: we would need to change the code in multiple files any time we wanted to update the service."
msgstr ""

#: ../developer/services/qrexec.md:208
#: c1c71227db41424b9827346c4cea6c6d
msgid "For this reason it is possible to specify a service argument, which will be subject to a policy. A service argument can make service policies more fine-grained. With arguments, it is easier to write more precise policies using the \"allow\" and \"deny\" actions, instead of relying on the \"ask\" method. (Writing too many \"ask\" policies offloads additional decisions to the user. Generally, the fewer choices the user must make, the lower the chance to make a mistake.)"
msgstr ""

#: ../developer/services/qrexec.md:214
#: 89db6ba0b4524b379fcd6373c79dd113
msgid "Each specific argument that we want to use needs its own policy in dom0 at a path like `/etc/qubes-rpc/policy/RPC_ACTION_NAME+ARGUMENT`. So for instance, we might have policies called `test.Device`, `test.Device+device1` and `test.Device+device2`. If the policy for the specific argument is not set (that is, if no file exists for `RPC_ACTION_NAME+ARGUMENT`), then dom0 uses the default policy with no argument for this service."
msgstr ""

#: ../developer/services/qrexec.md:218
#: faa1f05b699746a78b27600f942c82ca
msgid "When calling a service that takes an argument, just add the argument to the service name separated with `+`."
msgstr ""

#: ../developer/services/qrexec.md:224
#: fc55d22421ee4145ba14bafe1590e7d5
msgid "The script will receive `ARGUMENT` as its argument. The argument will also become available as the `QREXEC_SERVICE_ARGUMENT` environment variable. This means it is possible to install a different script for a particular service argument."
msgstr ""

#: ../developer/services/qrexec.md:228
#: e026dbea0ad84a0084406eb62dcaaea7
msgid "See [below](#rpc-service-with-argument-file-reader) for an example of an RPC service using an argument."
msgstr ""

#: ../developer/services/qrexec.md:232
#: 7fe9fdf5c9f745a78b709e09c2273442
msgid "Qubes RPC examples"
msgstr ""

#: ../developer/services/qrexec.md:234
#: 489de7299de8433cbb5030ff21bb0db1
msgid "To demonstrate some of the possibilities afforded by the qrexec framework, here are two examples of custom RPC services."
msgstr ""

#: ../developer/services/qrexec.md:236
#: c5ee3db7124c42239f58f3b090c88b44
msgid "Simple RPC service (addition)"
msgstr ""

#: ../developer/services/qrexec.md:238
#: e4f42f9d68044979842917227acafcc4
msgid "We can create an RPC service that adds two integers in a target domain (the server, call it \"anotherVM\") and returns back the result to the invoker (the client, \"someVM\"). In someVM, create a file with the following contents and save it with the path `/usr/bin/our_test_add_client`:"
msgstr ""

#: ../developer/services/qrexec.md:247
#: 9d28f8ab4a7e4804a5f0c26be2a32c33
msgid "Our server will be anotherVM at `/usr/bin/our_test_add_server`. The code for this file is:"
msgstr ""

#: ../developer/services/qrexec.md:256
#: 90964f1cb64b4736889124ccdb9d0588
msgid "We'll need to create a service called `test.Add` with its own definition and policy file in dom0. Now we need to define what the service does. In this case, it should call our addition script. We define the service with a symlink at `/etc/qubes-rpc/test.Add` pointing to our server script (the script can be also placed directly in `/etc/qubes-rpc/test.Add` - make sure the file has executable bit set!):"
msgstr ""

#: ../developer/services/qrexec.md:265
#: 6c4ce06056f54c2b90a1dec38032c204
msgid "The administrative domain will direct traffic based on the current RPC policies. In dom0, create a file at `/etc/qubes-rpc/policy/test.Add` containing the following:"
msgstr ""

#: ../developer/services/qrexec.md:272
#: 84f573b2dee04ba683eed224106388de
msgid "This will allow our client and server to communicate."
msgstr ""

#: ../developer/services/qrexec.md:274
#: 7e4ac9fc450d4593aac1bcf3600a7b61
msgid "Before we make the call, ensure that the client and server scripts have executable permissions. Finally, invoke the RPC service."
msgstr ""

#: ../developer/services/qrexec.md:281
#: 41f7e2302de744199701b0bb2a84cc4a
msgid "We should get \"3\" as answer. (dom0 will ask for confirmation first.)"
msgstr ""

#: ../developer/services/qrexec.md:284
#: 772a39da78304c4bbd20aa8429c21b13
msgid "**Note:** For a real world example of writing a qrexec service, see this [blog post](https://blog.invisiblethings.org/2013/02/21/converting-untrusted-pdfs-into-trusted.html)."
msgstr ""

#: ../developer/services/qrexec.md:286
#: bbcede1932c9463fa63ea498bcca3351
msgid "RPC service with argument (file reader)"
msgstr ""

#: ../developer/services/qrexec.md:288
#: 16b88254094144c3bd233ec08fbf95e4
msgid "Here we create an RPC call that reads a specific file from a predefined directory on the target. This example uses an [argument](#service-policies-with-arguments) to the policy. In this example a simplified workflow will be used. The service code is placed directly in the service definition file on the target VM. No separate client script will be needed."
msgstr ""

#: ../developer/services/qrexec.md:293
#: 60de5c9c5657412897ec72f69eae8420
msgid "First, on your target VM, create two files in the home directory: `testfile1` and `testfile2`. Have them contain two different \"Hello world!\" lines."
msgstr ""

#: ../developer/services/qrexec.md:296
#: fc7f393827b84d798ddfc9c5f46efd00
msgid "Next, we define the RPC service. On the target VM, place the code below at `/etc/qubes-rpc/test.File`:"
msgstr ""

#: ../developer/services/qrexec.md:309
#: 497be98f73b246839c28d593a3cad33d
msgid "Make sure the file is executable! (The service argument is already sanitized by qrexec framework. It is guaranteed to not contain any spaces or slashes, so there should be no need for additional path sanitization.)"
msgstr ""

#: ../developer/services/qrexec.md:313
#: 12368d502e7d4057ae4c80b988efc28e
msgid "Now we create three policy files in dom0. See the table below for details. Replace \"source_vm1\" and others with the names of your own chosen domains."
msgstr ""

#: ../developer/services/qrexec.md:317
#: 4fa3b1983f0247fda45d1326b7418e70
msgid "|------------------------------------------------------------------------| | Path to file in dom0                      | Policy contents            | |-------------------------------------------+----------------------------| | /etc/qubes-rpc/policy/test.File           | @anyvm @anyvm deny         | | /etc/qubes-rpc/policy/test.File+testfile1 | source_vm1 target_vm allow | | /etc/qubes-rpc/policy/test.File+testfile2 | source_vm2 target_vm allow | |------------------------------------------------------------------------|"
msgstr ""

#: ../developer/services/qrexec.md:325
#: 128dd6e69248411a943a8cf1ee1f7c9b
msgid "With this done, we can run some tests. Invoke RPC from `source_vm1` via"
msgstr ""

#: ../developer/services/qrexec.md:332
#: 56661a31634946cd995ce6d3e3776195
msgid "We should get the contents of `/home/user/testfile1` printed to the terminal. Invoking the service from `source_vm2` should work the same, and `testfile2` should also work."
msgstr ""

#: ../developer/services/qrexec.md:340
#: 7fd22d3f4b9d4287bc9e5aea844ecb55
msgid "But when invoked with other arguments or from a different VM, it should be denied."
msgstr ""
